#!/usr/bin/env ruby


###############
#     Odd     #
###############

class Nanoc::Item
  def +@
    self[:object]
  end   
end

# compile default files created by nanoc:
compile('/'){ layout 'default' };  route('/'){'/index.html'}
compile('/stylesheet/'){};         route('/stylesheet/'){'/style.css'}

@file = '../log.txt'
def log?
  File.exist?(@file) ? File.read(@file) : ''
end
def log data
  File.write @file, log? + "\n#{ data }"
end


#################
#    Layouts    #
#################

# The first matching rule is used:

# layout '*', :erb
# layout '/default/', :slim
# layout '/default/', :haml, format: :html5
# layout %r{^/_.+/$}, :erb
# /default/ may be layouts/default.with-any-extension

# all unmatched layouts will be compiled using filter determined by extension:

FakeItems.new('layouts').items.each do |item|
  layout item.identifier, FilterFor[item.file]
end


#################
#     Items     #
#################

module Preprocessor  # one .preprocess per item!

  def preprocess! context, classes

    while item = context.items.find { |item| !(+item) || !(+item).processed? }
      item[:object] = classes[item].new(item) unless +item
      (+item).do_preprocess context
    end
  end
end

fake = FakeItems.new('content')
classes = ItemClass.new
extend Preprocessor; preprocess! fake, classes


###################
#  Compile/Route  #
###################

fake.items.each do |item|
    
  compile (+item).identifier do
    (+item).compile self
  end
  
  route (+item).identifier do
    (+item).route
  end  
end


##################
#   Preprocess   #
##################

@preprocess = -> context do
  extend Preprocessor; preprocess! context, classes
end

preprocess &@preprocess